{
  "id": "promises",
  "title": "JS Promises",
  "group": "JS Async",
  "content": [
    { "type": "h1", "text": "JavaScript Promises" },
    { "type": "p", "text": "A Promise is an object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. Promises provide a cleaner alternative to callbacks for handling asynchronous code." },

    { "type": "h2", "text": "Creating a Promise" },
    { "type": "p", "text": "A Promise is created using the new Promise() constructor. It takes a function (executor) with two parameters: resolve (called on success) and reject (called on failure)." },
    { "type": "example", "title": "new Promise()", "code": [
      "const myPromise = new Promise(function(resolve, reject) {",
      "  const success = true;",
      "",
      "  if (success) {",
      "    resolve('Operation succeeded!');",
      "  } else {",
      "    reject('Operation failed!');",
      "  }",
      "});",
      "",
      "console.log(myPromise);",
      "console.log(typeof myPromise);"
    ]},

    { "type": "h2", "text": "resolve and reject" },
    { "type": "p", "text": "When an async operation succeeds, call resolve() with the result value. When it fails, call reject() with the error. A promise can only be resolved or rejected once." },
    { "type": "example", "title": "Resolve and Reject", "code": [
      "function checkAge(age) {",
      "  return new Promise(function(resolve, reject) {",
      "    if (age >= 18) {",
      "      resolve('Access granted. Age: ' + age);",
      "    } else {",
      "      reject('Access denied. Must be 18+.');",
      "    }",
      "  });",
      "}",
      "",
      "checkAge(20).then(function(message) {",
      "  console.log(message);",
      "});",
      "",
      "checkAge(15).catch(function(error) {",
      "  console.log(error);",
      "});"
    ]},

    { "type": "h2", "text": ".then(), .catch(), and .finally()" },
    { "type": "p", "text": "The .then() method handles the resolved value, .catch() handles rejections/errors, and .finally() runs regardless of the outcome. These methods return new promises, enabling chaining." },
    { "type": "example", "title": "then, catch, finally", "code": [
      "function fetchUser(id) {",
      "  return new Promise(function(resolve, reject) {",
      "    if (id > 0) {",
      "      resolve({ id: id, name: 'User ' + id });",
      "    } else {",
      "      reject('Invalid user ID');",
      "    }",
      "  });",
      "}",
      "",
      "fetchUser(1)",
      "  .then(function(user) {",
      "    console.log('Found: ' + user.name);",
      "  })",
      "  .catch(function(error) {",
      "    console.log('Error: ' + error);",
      "  })",
      "  .finally(function() {",
      "    console.log('Operation complete');",
      "  });"
    ]},

    { "type": "h2", "text": "Promise Chaining" },
    { "type": "p", "text": "Since .then() returns a new promise, you can chain multiple .then() calls together. Each .then() receives the result of the previous .then() as its argument." },
    { "type": "example", "title": "Chaining Promises", "code": [
      "function double(value) {",
      "  return new Promise(function(resolve) {",
      "    resolve(value * 2);",
      "  });",
      "}",
      "",
      "double(5)",
      "  .then(function(result) {",
      "    console.log('First: ' + result);",
      "    return double(result);",
      "  })",
      "  .then(function(result) {",
      "    console.log('Second: ' + result);",
      "    return double(result);",
      "  })",
      "  .then(function(result) {",
      "    console.log('Third: ' + result);",
      "  });"
    ]},

    { "type": "h2", "text": "Promise Static Methods" },
    { "type": "p", "text": "Promise provides several static methods for working with multiple promises: Promise.all(), Promise.race(), Promise.allSettled(), and Promise.any()." },
    { "type": "table", "rows": [
      ["Method", "Resolves when", "Rejects when"],
      ["Promise.all()", "All promises resolve", "Any promise rejects"],
      ["Promise.race()", "First promise settles", "First promise rejects"],
      ["Promise.allSettled()", "All promises settle", "Never rejects"],
      ["Promise.any()", "Any promise resolves", "All promises reject"]
    ]},
    { "type": "example", "title": "Promise.all() and Promise.race()", "code": [
      "const p1 = Promise.resolve('One');",
      "const p2 = Promise.resolve('Two');",
      "const p3 = Promise.resolve('Three');",
      "",
      "// Promise.all - waits for all",
      "Promise.all([p1, p2, p3]).then(function(values) {",
      "  console.log('All: ' + values);",
      "});",
      "",
      "// Promise.race - first to settle",
      "Promise.race([p1, p2, p3]).then(function(value) {",
      "  console.log('Race winner: ' + value);",
      "});",
      "",
      "// Promise.allSettled - all results",
      "const p4 = Promise.reject('Error!');",
      "Promise.allSettled([p1, p4]).then(function(results) {",
      "  results.forEach(function(r) {",
      "    console.log(r.status + ': ' + (r.value || r.reason));",
      "  });",
      "});"
    ]},

    { "type": "note", "text": "A promise is in one of three states: pending (initial state), fulfilled (operation completed successfully), or rejected (operation failed). Once a promise is fulfilled or rejected, it is settled and its state cannot change." },

    { "type": "exercise", "question": "What does Promise.all() do when one of the promises rejects?", "options": ["It resolves with partial results", "It waits for all promises to settle", "It immediately rejects with that error", "It ignores the rejection"], "answer": 2 }
  ]
}
