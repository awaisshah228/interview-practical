{
  "id": "object_this",
  "title": "JS Object this",
  "group": "JS Objects",
  "content": [
    { "type": "h1", "text": "JavaScript this Keyword" },
    { "type": "p", "text": "The 'this' keyword in JavaScript refers to the object that is currently executing the code. Unlike most languages, the value of 'this' is not determined by where a function is defined, but by how it is called. This is one of the trickiest concepts in JavaScript." },

    { "type": "h2", "text": "this in the Global Context" },
    { "type": "p", "text": "In the global execution context (outside any function), 'this' refers to the global object. In a browser, that's the window object. In Node.js, it's the global object. In strict mode at the top level of a module, 'this' is undefined." },
    { "type": "example", "title": "Global this", "code": [
      "// In the global context",
      "console.log(typeof this);",
      "",
      "// In a regular function (non-strict mode)",
      "function showThis() {",
      "  console.log(\"Function this:\", typeof this);",
      "}",
      "showThis();",
      "",
      "// In strict mode",
      "function strictThis() {",
      "  \"use strict\";",
      "  console.log(\"Strict this:\", this);",
      "}",
      "strictThis();"
    ]},

    { "type": "h2", "text": "this in Object Methods" },
    { "type": "p", "text": "When a function is called as a method of an object (obj.method()), 'this' refers to the object that owns the method. This is the most common and intuitive use of 'this'." },
    { "type": "example", "title": "this in Methods", "code": [
      "let person = {",
      "  name: \"Alice\",",
      "  age: 30,",
      "  greet() {",
      "    console.log(`Hi, I'm ${this.name}`);",
      "    console.log(`I'm ${this.age} years old`);",
      "  }",
      "};",
      "",
      "person.greet();",
      "",
      "// 'this' depends on the calling object",
      "let another = {",
      "  name: \"Bob\",",
      "  age: 25,",
      "  greet: person.greet",
      "};",
      "",
      "another.greet();"
    ]},

    { "type": "h2", "text": "this in Arrow Functions" },
    { "type": "p", "text": "Arrow functions do NOT have their own 'this'. They inherit 'this' from the enclosing (lexical) scope — the scope where they are defined. This makes them ideal for callbacks inside methods but problematic as object methods themselves." },
    { "type": "example", "title": "Arrow Functions and this", "code": [
      "let team = {",
      "  name: \"Dev Team\",",
      "  members: [\"Alice\", \"Bob\", \"Charlie\"],",
      "",
      "  // Arrow function inherits 'this' from listMembers",
      "  listMembers() {",
      "    this.members.forEach(member => {",
      "      console.log(`${member} is in ${this.name}`);",
      "    });",
      "  }",
      "};",
      "",
      "team.listMembers();",
      "",
      "// DON'T use arrow functions as methods!",
      "let broken = {",
      "  name: \"Broken\",",
      "  greet: () => {",
      "    console.log(`Name: ${this.name}`);",
      "  }",
      "};",
      "",
      "broken.greet();"
    ]},

    { "type": "h2", "text": "Explicit Binding: bind(), call(), apply()" },
    { "type": "p", "text": "You can explicitly set the value of 'this' using bind(), call(), or apply(). bind() returns a new function with 'this' permanently set. call() and apply() invoke the function immediately with a specific 'this'." },
    { "type": "example", "title": "Explicit this Binding", "code": [
      "function greet(greeting) {",
      "  console.log(`${greeting}, I'm ${this.name}`);",
      "}",
      "",
      "let alice = { name: \"Alice\" };",
      "let bob = { name: \"Bob\" };",
      "",
      "// call() — invoke with specific 'this'",
      "greet.call(alice, \"Hello\");",
      "greet.call(bob, \"Hi\");",
      "",
      "// apply() — same but args as array",
      "greet.apply(alice, [\"Hey\"]);",
      "",
      "// bind() — create new function with fixed 'this'",
      "let aliceGreet = greet.bind(alice);",
      "aliceGreet(\"Howdy\");",
      "",
      "// bind is useful for callbacks",
      "let timer = {",
      "  name: \"Timer\",",
      "  start() {",
      "    setTimeout(function() {",
      "      console.log(this.name);",
      "    }.bind(this), 0);",
      "  }",
      "};",
      "timer.start();"
    ]},

    { "type": "h2", "text": "Common Pitfalls" },
    { "type": "p", "text": "The most common mistake is losing the 'this' context when passing a method as a callback, extracting it from an object, or using it in a nested function. Understanding these pitfalls prevents many bugs." },
    { "type": "example", "title": "this Pitfalls and Solutions", "code": [
      "let user = {",
      "  name: \"Alice\",",
      "  greet() {",
      "    console.log(`Hi, ${this.name}`);",
      "  }",
      "};",
      "",
      "// PITFALL: extracting method loses 'this'",
      "let fn = user.greet;",
      "// fn();  // 'this' is undefined or global",
      "",
      "// Solution 1: bind()",
      "let boundFn = user.greet.bind(user);",
      "boundFn();",
      "",
      "// Solution 2: arrow function wrapper",
      "let wrapper = () => user.greet();",
      "wrapper();",
      "",
      "// PITFALL: nested function in method",
      "let counter = {",
      "  count: 0,",
      "  increment() {",
      "    // Save 'this' reference",
      "    const self = this;",
      "    function innerAdd() {",
      "      self.count++;",
      "    }",
      "    innerAdd();",
      "    console.log(this.count);",
      "  }",
      "};",
      "counter.increment();"
    ]},

    { "type": "table", "rows": [
      ["Context", "this Value"],
      ["Global (non-strict)", "Global object (window)"],
      ["Global (strict)", "undefined"],
      ["Object method", "The object"],
      ["Arrow function", "Inherited from enclosing scope"],
      ["Constructor (new)", "The new object"],
      ["call()/apply()", "First argument"],
      ["bind()", "Bound object"],
      ["Event handler", "The element (DOM)"]
    ]},

    { "type": "note", "text": "When in doubt about 'this', remember: arrow functions inherit it, regular functions get it from the caller. If you need a fixed 'this' in callbacks, use arrow functions or .bind(). Never use arrow functions as object methods if you need 'this' to refer to the object." },

    { "type": "exercise", "question": "What does 'this' refer to inside an arrow function?", "options": ["The object the arrow function belongs to", "The global object", "undefined", "The enclosing (lexical) scope's this"], "answer": 3 }
  ]
}
