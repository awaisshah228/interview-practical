{
  "id": "async_await",
  "title": "JS Async/Await",
  "group": "JS Async",
  "content": [
    { "type": "h1", "text": "JavaScript Async/Await" },
    { "type": "p", "text": "Async/await is syntactic sugar built on top of Promises. It allows you to write asynchronous code that looks and behaves like synchronous code, making it easier to read and maintain." },

    { "type": "h2", "text": "The async Keyword" },
    { "type": "p", "text": "The async keyword is placed before a function declaration to make it an async function. An async function always returns a promise. If the function returns a value, the promise is resolved with that value." },
    { "type": "example", "title": "async Function", "code": [
      "async function greet() {",
      "  return 'Hello, World!';",
      "}",
      "",
      "// An async function returns a Promise",
      "greet().then(function(message) {",
      "  console.log(message);",
      "});",
      "",
      "// Equivalent to:",
      "function greetPromise() {",
      "  return Promise.resolve('Hello, World!');",
      "}",
      "",
      "greetPromise().then(function(message) {",
      "  console.log('Promise version: ' + message);",
      "});"
    ]},

    { "type": "h2", "text": "The await Keyword" },
    { "type": "p", "text": "The await keyword can only be used inside an async function. It pauses the execution of the async function until the promise is resolved, and then returns the resolved value." },
    { "type": "example", "title": "Using await", "code": [
      "function delay(ms) {",
      "  return new Promise(function(resolve) {",
      "    setTimeout(resolve, ms);",
      "  });",
      "}",
      "",
      "async function demo() {",
      "  console.log('Starting...');",
      "  await delay(1000);",
      "  console.log('After 1 second');",
      "  await delay(1000);",
      "  console.log('After 2 seconds');",
      "  return 'Done!';",
      "}",
      "",
      "demo().then(function(result) {",
      "  console.log(result);",
      "});"
    ]},

    { "type": "h2", "text": "Error Handling with try/catch" },
    { "type": "p", "text": "With async/await, you can use standard try/catch blocks to handle errors, just like synchronous code. This replaces the .catch() method used with promises." },
    { "type": "example", "title": "try/catch with async/await", "code": [
      "function fetchData(shouldFail) {",
      "  return new Promise(function(resolve, reject) {",
      "    if (shouldFail) {",
      "      reject(new Error('Data fetch failed!'));",
      "    } else {",
      "      resolve({ id: 1, name: 'Product' });",
      "    }",
      "  });",
      "}",
      "",
      "async function getData() {",
      "  try {",
      "    const data = await fetchData(false);",
      "    console.log('Success: ' + data.name);",
      "",
      "    const bad = await fetchData(true);",
      "    console.log('This will not run');",
      "  } catch (error) {",
      "    console.log('Caught: ' + error.message);",
      "  }",
      "}",
      "",
      "getData();"
    ]},

    { "type": "h2", "text": "Async Arrow Functions" },
    { "type": "p", "text": "You can also create async arrow functions. The async keyword comes before the parameter list." },
    { "type": "example", "title": "Async Arrow Functions", "code": [
      "const fetchUser = async (id) => {",
      "  return { id: id, name: 'User ' + id };",
      "};",
      "",
      "const processUser = async (id) => {",
      "  const user = await fetchUser(id);",
      "  console.log('Processing: ' + user.name);",
      "  return user;",
      "};",
      "",
      "processUser(42).then(function(user) {",
      "  console.log('Result: ' + JSON.stringify(user));",
      "});"
    ]},

    { "type": "h2", "text": "Sequential vs Parallel Execution" },
    { "type": "p", "text": "By default, multiple await statements run sequentially. To run promises in parallel, use Promise.all() with await. This is important for performance when tasks are independent." },
    { "type": "example", "title": "Sequential vs Parallel await", "code": [
      "function fetchItem(name, ms) {",
      "  return new Promise(function(resolve) {",
      "    setTimeout(function() {",
      "      resolve(name);",
      "    }, ms);",
      "  });",
      "}",
      "",
      "// Sequential (slower)",
      "async function sequential() {",
      "  const a = await fetchItem('A', 100);",
      "  const b = await fetchItem('B', 100);",
      "  console.log('Sequential: ' + a + ', ' + b);",
      "}",
      "",
      "// Parallel (faster)",
      "async function parallel() {",
      "  const [a, b] = await Promise.all([",
      "    fetchItem('A', 100),",
      "    fetchItem('B', 100)",
      "  ]);",
      "  console.log('Parallel: ' + a + ', ' + b);",
      "}",
      "",
      "sequential();",
      "parallel();"
    ]},

    { "type": "table", "rows": [
      ["Feature", "Promises", "Async/Await"],
      ["Syntax", ".then()/.catch()", "await / try-catch"],
      ["Readability", "Chain-based", "Looks synchronous"],
      ["Error handling", ".catch()", "try/catch"],
      ["Debugging", "Harder (async stack)", "Easier (step through)"],
      ["Parallel execution", "Promise.all()", "await Promise.all()"]
    ]},

    { "type": "note", "text": "The await keyword only pauses the execution of the async function it is in, not the entire program. Other code outside the async function continues to run. Top-level await is available in ES modules, allowing you to use await outside of async functions in module contexts." },

    { "type": "exercise", "question": "What does the await keyword do?", "options": ["Stops the entire program", "Pauses the async function until the promise resolves", "Creates a new promise", "Runs code in parallel"], "answer": 1 }
  ]
}
